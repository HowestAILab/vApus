\section{Over Viewing the Fundaments {\bf(D)}}
\img[h!]{width=13cm}{Over_Viewing_the_Fundaments_(D).PNG}{vApus v2 Main Window}
Before talking about stresstesting and all that it is best to explain vApus v2 at its core, and why it is better than the fundaments in v1, in a nutshell:
\begin{itemize}
\item No addin-stuff, SharpDevelop Add-in tree architecture, like it was in the old vApus (Difficult to implement/debug, must do the same stuff per visual studio project, slow compilation)
\item Not bloated but light weighted
\item No builder classes (saving, loading; showing in the tree view) per vApus solution item but centralized and automated in the framework
\item ...
\end{itemize}
 and easily to build new modules because vApus v2 is built like a, as good as, self-managed framework.
One quick note, building vApus v2 was first done in Visual Studio 2008 and later in Visual Studio 2010 in C\#. .net 4.0 is the used API.

\subsection{Static GUI}
\img[h!]{width=5cm}{Static_GUI_1.PNG}{MainWindow.cs in the Visual Studio Solution Explorer}
\img[h!]{width=5cm}{Static_GUI_2.PNG}{Document Outline of MainWindow.cs}
Or the "Hard Coded" GUI. Instead of a standard MDI application there was opted to use a dock panel (http://sourceforge.net/projects/dockpanelsuite) where different forms can be shown as tabs just like in Visual Studio.
Note: this was also the case in the previous vApus, only unnecessary classes where implemented upon the referenced .dll. Now the source is a bit adapted and is compiled with vApus v2. (Just a tab page that when trying to close only hides and that can only have one instance.)
\img[h!]{width=5cm}{Static_GUI_3.PNG}{"Hard Coded" GUI}

The main menu is static too, for the ease of development. For instance, menu items like "New" and "Open" but also the items "Distributed" and "Single Test" are hard coded.
But their childs are not static nor are their images (except "View ? Stresstesting Solution Explorer", which does have a dynamically loaded image).
The reason I talk about this first is because there is but a loose connection between the static GUI and the framework, the only thing that deeply interacts is the filling of the menu items "Recent Solutions", "Monitor",  "Distributed" and "Single Test".
The "About"-folder in the project will be discussed in chapter "Other".

\subsection{Managing Modules {The Actual Framework}}
\img[h!]{width=5cm}{Managing_Modules_1.PNG}{vApus.SolutionTree}
\img[h!]{width=2cm}{Managing_Modules_2.PNG}{vApus.Linker}
This is the complete core of "vApus as a framework"/vApus v2. The six main items are:
\begin{itemize}
\item Solution
\npar
This is self-managed, it keeps stuff like:
\begin{itemize}
\item The active solution (can be only one)
\item The recent opened/saved solutions (a list of maximum 10 items)
\item The stresstesting solution explorer
\item The project group types built upon the framework (further)
\end{itemize}
\npar
and has the functionality to:
\begin{itemize}
\item Register project group types
\item Create new, save , load
\item Build tree nodes (reflection)
\item Notify if the solution has changed
\end{itemize}
\item SolutionComponent
\npar
The base building block for "BaseProject" and "BaseItem" ("LabeledBaseItem" inherits from "BaseItem") and holds functionality for:
\begin{itemize}
\item Building treenodes and giving back savable data (xml and reflection (attributes))
\item Building a context menu and some basic context menu item invocation targets
\item Getting the appropriate image
\item Adding stuff as standard items
\item Notifies if the component has changed
\item This can be called everywhere and since a static event is invoked, everything will know if something is changed.
\npar
\begin{codelisting}
public void InvokeSolutionComponentChangedEvent(SolutionComponentChangedEventArgs.DoneAction doneAction)
public void InvokeSolutionComponentChangedEvent(SolutionComponentChangedEventArgs.DoneAction doneAction, object arg)
\end{codelisting}
\item ...
\end{itemize}
\npar
and is approachable like a collection (of "BaseItem"-s).
\item Stresstesting Solution Explorer
\item BaseSolutionComponentView
\npar
Every view that is shown as dockable content must override from this class. (Further)
\item SolutionComponentViewManager
\npar
For every item shown in the solution explorer any view can be shown/managed using this manager (Discussed later on).
\item Linker
\npar
Used to register the project groups when the application starts (avoiding circular dependencies).
\npar
\begin{codelisting}
Solution.RegisterProjectType(typeof(StresstestProject));
\end{codelisting}
\end{itemize}

\subsection{Generated GUI}
\img[h!]{width=5cm}{Generated_GUI.PNG}{Stresstesting Solution Explorer}
\subsubsection{Stresstesting Solution Explorer}
The solution class holds a static solution explorer, which is nothing more than e tree view and property grid. Changes to the solution, like property changes, are invoked with an event.

Solution will notify to the explorer when he should reload completely (new or opened solution) or just some parts (add, remove, clear).

It also provides functionality to edit labels of "LabeledBaseItems".
\subsubsection{Tree Nodes}
SolutionComponent " gives back its, and its childs, treenodes. It links a context menu to the nodes if applicable.
\begin{codelisting}
public TreeNode GetTreeNode(){...
\end{codelisting}
An image is automatically applied if the resource is provided (see Resource Management).
\subsubsection{Context Menu's}
Context menu items are generated automatically based on attribute usage and reflection.

If the class attribute "ContextMenu" is provided in a class inheriting from "SolutionComponent" a context menu can be build.
\begin{codelisting}
[ContextMenu(new string[] { "Add_Click", "SortItemsByLabel_Click", "Clear_Click" }, new string[] { "Add Stresstest...", "Sort", "Clear" })]
public class StresstestProject : BaseProject {...
\end{codelisting}
The invocation target must be provided (void(object sender, EventArgs e) target),  a label is not obliged.

Some are already provided in "SolutionComponent":
\begin{itemize}
\item
\begin{codelisting}
internal void Activate_Click(object sender, EventArgs e){...
\end{codelisting}
\npar
A virtual function "Activate()" is provided, this is freely to override and do stuff in. By default a "SolutionComponentPropertyView" is shown for the calling type. (Further) 
\item
\begin{codelisting}
internal void Clear_Click(object sender, EventArgs e){...
\end{codelisting}
\npar
Asks for confirmation (message box) and clears.
\item
\begin{codelisting}
internal void SortItemsByLabel_Click(object sender, EventArgs e){...
\end{codelisting}
\npar
Sorts only the "LabeledBaseItems", the 'normal' ones are put at the beginning.
\end{itemize}
in "BaseItem":
\begin{itemize}
\item
\begin{codelisting}
internal void Import_Click(object sender, EventArgs e) {...
\end {codelisting}
\npar
Shows an Open File Dialog, asking for a valid xml file. This will check if a certain item is valid to be imported.
\item
\begin{codelisting}
internal void Summary_Click(object sender, EventArgs e) {...
\end{codelisting}
\npar
Discussed later on.
\item
\begin{codelisting}
internal void Remove_Click(object sender, EventArgs e) {...
\end{codelisting}
\npar
Asks for confirmation (message box) and removes.
\item
\begin{codelisting}
internal void Cut_Click(object sender, EventArgs e) {...
\end{codelisting}
\item
\begin{codelisting}
internal void Copy_Click(object sender, EventArgs e) {...
\end{codelisting}
\item
\begin{codelisting}
internal void Paste_Click(object sender, EventArgs e) {...
\end{codelisting}
\end{itemize}
And in "LabeledBaseItem":
\begin{itemize}
\item
\begin{codelisting}
internal void Export_Click(object sender, EventArgs e) {...
\end{codelisting}
\npar
The label is used as filename.
\end{itemize}
\paragraph{Hotkeys}
Hotkeys for the tree nodes can be set the same way as for setting context menu's.
Just the class attribute "Hotkeys" must be provided in a class inheriting from "SolutionComponent".
\begin{codelisting}
[ContextMenu(new string[] { "Edit_Click", "Remove_Click" }, new string[] { "Edit", "Remove" })]
[Hotkeys(new string[] { "Edit_Click", "Remove_Click" }, new Keys[] { Keys.Enter, Keys.Delete })]
public class StresstestProject : LabeledBaseItem {...
\end{codelisting}
\subparagraph{Renaming and Activating a Tree Node}
Tree nodes can be renamed using F2. If a hotkey for "Activate\_Click" is provided, double clicking will work too besides the hotkey.
\paragraph{Views}
For every item shown in the solution explorer any view can be shown/managed using the "SolutionComponentViewManager". This will update and close the views when needed.
Views can be made deriving from "BaseSolutionComponentView" and can be shown this way:
\begin{codelisting}
SolutionComponentViewManager.Show(this, typeof(SolutionComponentPropertyView));
\end{codelisting}

Or if the name of the view equals the ToString() of the solution component + "View":
\begin{codelisting}
SolutionComponentViewManager.Show(this);
\end{codelisting}

A default view: "SolutionComponentPropertyView" is already provided holding a "SolutionComponentPropertyPanel" which will add a "SolutionComponentCommonPropertyControl" for each property having the "PropertyControlAttribute".  A display index can be given with, if not property controls are alphabetically sorted.
("SolutionComponentPropertyPanel" can also be used freely in other views.)
\begin{codelisting}
[SavableCloneable, PropertyControl(1)]
public int[] Concurrencies
{
    get { return _concurrencies; }
    set { _concurrencies = value; }
}
\end{codelisting}

"SolutionComponentCommonPropertyControl" is applicable for all primary data types and for arrays/generic lists having a primary data type as element type and any object having an IEnumerable as parent (SetParent, GetParent extension method for object (further)).
For other types a custom property control can also be provided in the attribute, deriving from "BaseSolutionComponentPropertyControl".
 When doing this, always override the "Refresh()" function, because this is used to update the control when changes in the properties are made.

The "BaseItem" class also holds a function to show summary controls of each containing item.
\begin{codelisting}
internal virtual void Summary_Click(object sender, EventArgs e)
{
    SolutionComponentViewManager.Show(this, typeof(SolutionComponentSummaryView));
}
\end{codelisting}

As mentioned before, a virtual "Activate()" function has been provided in the "SolutionComponent" class, this is called when clicking the available link label displayed on a summary  control. You can override this yourself to show a custom view, by  default the "SolutionComponentPropertyView" is shown.

\subsection{Resource Management (Images)}
Each added module MUST have a "Resources.resx", even if it is always empty. Images for the different items are stored in there having the same name. Using reflection the correct image is found ("SolutionComponent" functionality) which can be (and is) used in menu's and tree views.
\begin{codelisting}
public Image GetImage(){...
\end{codelisting}

\subsection{File Management (Automated Saving, Loading and Cloning}
\begin{codelisting}
[SavableCloneable, PropertyControl]
public string Label
{
get { return _label; }
      set { _label = value == null ? string.Empty : value; }
}
\end{codelisting}

Using reflection and a property attribute stuff that must be saved can be specified. This way a "BaseProject" and a "BaseItem" can load from and give back xml. This is packaged in "Solution" using the OpenXML way (a zip-file holding xml files). 
Only primary data types and arrays/lists having a primary data type as element type and any object having an IEnumerable as parent (SetParent, GetParent extension method for object (further))  can be saved and loaded.
Note: Properties with the "SavableCloneable" attribute must have a getter and setter and may never be null! Use string.Empty as field value for strings, use BaseItem.Empty for BaseItems.
For 'IEnumerable items' a branched index is stored when saving to xml. It starts with the zero-based index of a upper parent and a '.' to branch until the direct parent of the item is reached followed with the index of the item itself. 
If the object is not a base item the parent field is stored also. Very Important: The parent of the object MUST always be set!
Example: 
\begin{codelisting}
_log = BaseItem.Empty(typeof(Log), Solution.ActiveSolution.GetSolutionComponent(typeof(Logs))) as Log;
\end{codelisting}

Results in:
\begin{codelisting}
<Log args="vApus.BranchedIndexType">2.2.1</Log>
\end{codelisting}
{\it(Stresstests/Logs/Log1)}
\npar
Furthermore any base items can be cut, copied, pasted, exported and imported.
Note: The culture of the main thread is set to "en-US" to make sure there is no issue with floating point numbers (points and comma's mix-up).

\subsection{Important Other Stuff}
The update and commit logic is adopted from vApus v1 and is basically the same. Also the about dialog is adopted, but now it gets authors and licenses from the resources and the history of changes from the "versioncontrol.ini" if any.
\begin{codelisting}
<Authors>
<Author name="Dieter Vandroemme" email="dieter@sizingservers.be, dieter.vandroemme@gmail.com" period="2006-2010" />
</Authors>
\end{codelisting}

Some things here are adopted from the previous vApus, such as "ExtendedListView", "InputDialog" and "StringUtil" who will not be discussed. Stuff that is applicable for stresstesting/monitoring/distributed testing will not be discussed here either.

\subsubsection{Comparers and Extensions}
These files hold following classes:
\begin{itemize}
\item PropertyInfoComparer
\npar
Designed using the singleton design pattern serves at sorting property info by name.
\item ControlComparer
\npar
Compares by text, to string, name, full name or a combination of these. 
\item AssemblyExtension
\npar
A static class which holds an extension method, "GetTypeByName", for Assembly.
\item TimeSpanExtension
\npar
Provides functionality to return usable formatted string.  Example: 13 minutes, 0 seconds.
\item StringExtension
\npar
To encrypt, decrypt, check if valid for Windows filenames and convert, check if is numeric.
\item CharExtension
\npar
Check if valid for Windows filenames, is digit and is numeric.
\item ObjectExtension
\npar
Set a tag and/or parent. This is a static class with static fields, so an own stack is made using a "HashTable" (very nifty I think). For tag (ditto for parent, wich is used defaultly in the framework when callin Add(BaseItem) on SolutionComponent for example):
\begin{codelisting}
private static Hashtable _tags = new Hashtable(), _parents = new Hashtable();
public static void SetTag(this object o, object tag)
{
    lock (_tags.SyncRoot)
        if (!_tags.Contains(o))
            _tags.Add(o, tag);
        else
            _tags[o] = tag;
}
public static object GetTag(this object o)
{
    //Threadsafe for reader threads.
    return _tags.Contains(o) ? _tags[o] : null;
}
\end{codelisting}
\end{itemize}

\subsubsection{SpecialFolder}
This can return all special folders, like "My Documents" or "Desktop".

\subsubsection{ClipboardWrapper}
Making setting and getting objects to and from the clipboard error safer due to build in retries and error handling.

\subsubsection{SocketWrapper}
A wrapper around the .net socket class handling synchronous communication and serializes/deserializes objects for you.

\subsubsection{SynchronizedContextWrapper}
To synchronize with the main thread (GUI) the synchronization context wrapper can be used (the most efficient way of thread synchronization IMHO). 
Example:
\begin{codelisting}
SynchronizationContextWrapper.SynchronizationContext.Send(delegate
{ ... }, null);
\end{codelisting}

\subsubsection{Win32WindowMessageHandler}
Serves to register a window message to the application which can be captured in a form using something like this:
\begin{codelisting}
protected override void WndProc(ref Message m)
{
	if (_msgHandler != null && m.Msg == _msgHandler.WINDOW_MSG)
	{
        this.TopMost = true;
        this.TopMost = false;
        this.Activate();
	}
	base.WndProc(ref m);
}
\end{codelisting}