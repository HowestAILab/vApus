<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RandomUtils</name>
    </assembly>
    <members>
        <member name="T:RandomUtils.BackgroundWorkQueue">
            <summary>
            To offload work to a background thread and keeping that work in a synchronized order.
            </summary>
        </member>
        <member name="F:RandomUtils.BackgroundWorkQueue._processWorkQueueWaitHandle">
            <summary>
            If this is set all items in the work queue will be processed, except if this processing is paused.
            </summary>
        </member>
        <member name="F:RandomUtils.BackgroundWorkQueue._continueWaitHandle">
            <summary>
            Used for pausing and continuing processing the work queue.
            </summary>
        </member>
        <member name="F:RandomUtils.BackgroundWorkQueue._idleWaitHandle">
            <summary>
            Used for pausing and continuing processing the work queue.
            </summary>
        </member>
        <member name="M:RandomUtils.BackgroundWorkQueue.#ctor">
            <summary>
            To offload work to a background thread and keeping that work in a synchronized order.
            </summary>
        </member>
        <member name="M:RandomUtils.BackgroundWorkQueue.Finalize">
            <summary></summary>
        </member>
        <member name="M:RandomUtils.BackgroundWorkQueue.Dispose">
            <summary>
            Releases all resources used.
            </summary>
        </member>
        <member name="M:RandomUtils.BackgroundWorkQueue.Dispose(System.Int32)">
            <summary>
            <para>Releases all resources used.</para>
            <para>Waits the given timeout before disposing (0 is acceptable, , smaller than 0 is indefinetly), if the work is not done it will be aborted.</para>
            </summary>
            <param name="millisecondsTimeout"></param>
        </member>
        <member name="M:RandomUtils.BackgroundWorkQueue.PauseProcessingWorkQueue">
            <summary>
            <para>Pauses the processing of the work queue and blocks until the processing is effectively paused.</para>
            <para>Continue this processing calling 'ContinueProcessingWorkQueue()'.</para>
            </summary>
        </member>
        <member name="M:RandomUtils.BackgroundWorkQueue.ContinueProcessingWorkQueue">
            <summary>
            Resumes the processing of the work queue.
            </summary>
        </member>
        <member name="M:RandomUtils.BackgroundWorkQueue.EnqueueWorkItem(System.Delegate,System.Object[])">
            <summary>
            <para>Adds a delegate on the work queue, that work queue is processed by a background thread, threadsafe.</para>
            <para>The delegates on that queue are invoked in a synchronized order.</para>
            <para></para>
            <para>Define your delegate like so:</para>
            <para>  <code>delegate T del(T, out T);</code> (Action or Func is also possible.)</para>
            <para>then pass your function using this signature:</para>
            <para>  <code>BackgroundWorkQueue.Send(new del(function), value, value);</code></para>
            <para>The return type may be void and args are not obligatory.</para>
            <para>Make sure you provide the right amount of args, even if it are out parameters (yes that is possible too).</para>
            </summary>
            <param name="del"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:RandomUtils.BackgroundWorkQueue.Flush">
            <summary>
            Wait untill all work queue items are processed.
            </summary>
        </member>
        <member name="E:RandomUtils.BackgroundWorkQueue.OnWorkItemProcessed">
            <summary>
            Invoked if an enqueued work item (function) was invoked successfully or unsuccessfully.
            </summary>
        </member>
        <member name="P:RandomUtils.BackgroundWorkQueue.IsDisposed">
            <summary> </summary>
        </member>
        <member name="T:RandomUtils.BackgroundWorkQueue.OnWorkItemProcessedEventArgs">
            <summary>
            The result of a called function or the exception thrown.
            </summary>
        </member>
        <member name="F:RandomUtils.BackgroundWorkQueue.OnWorkItemProcessedEventArgs.Delegate">
            <summary></summary>
        </member>
        <member name="F:RandomUtils.BackgroundWorkQueue.OnWorkItemProcessedEventArgs.Parameters">
            <summary>
                Out parameters are stored here too.
            </summary>
        </member>
        <member name="F:RandomUtils.BackgroundWorkQueue.OnWorkItemProcessedEventArgs.ReturnValue">
            <summary></summary>
        </member>
        <member name="F:RandomUtils.BackgroundWorkQueue.OnWorkItemProcessedEventArgs.Exception">
            <summary></summary>
        </member>
        <member name="M:RandomUtils.BackgroundWorkQueue.OnWorkItemProcessedEventArgs.#ctor(System.Delegate,System.Object[],System.Object,System.Exception)">
            <summary>
            The result of a called function or the exception thrown.
            </summary>
            <param name="del"></param>
            <param name="parameters"></param>
            <param name="returnValue"></param>
            <param name="exception"></param>
        </member>
        <member name="T:RandomUtils.FastObjectCreator">
            <summary>
            <para>Creates a new instance of a type using an empty public constructor and Intermediate Language. This is faster than Activator.CreateInstance(...),
            and unsafer since there are no checks. Do a comparison if you like.</para>
            <para>However, for primitives and structs Activator is used since they cannot have an explicit parameterless constructor.</para>
            This is thread-safe.
            </summary>
        </member>
        <member name="M:RandomUtils.FastObjectCreator.CreateInstance``1(System.Type)">
            <summary>
            <para>Creates a new instance of a type using an empty public constructor and Intermediate Language. This is faster than Activator.CreateInstance(...),
            and unsafer since there are no checks. Do a comparison if you like.</para>
            <para>However, for primitives and structs Activator is used since they cannot have an explicit parameterless constructor.</para>
            This is thread-safe.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:RandomUtils.FunctionOutputCache">
            <summary>
            <para>A thread-safe way to cache the calling function's return value / output arguments.</para>
            <para>This should only be used for output that always stays the same, but takes long to calculate.</para>
            <para>You can use the instance if you want one general FunctionOutputCache.</para>
            <para>I made this class before I knew you can do the same with System.Web.Caching.Cache (HttpContext.Current.Cache).</para>
            </summary>
        </member>
        <member name="M:RandomUtils.FunctionOutputCache.GetInstance">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.FunctionOutputCache.GetOrAdd(System.Reflection.MethodBase,System.Object[])">
            <summary>
            <para>Returns the entry if it was found in cache. Otherwise a new one is added to the cache and returned.</para>
            <para>Store the return value and/or output arguments for the calling function in that new entry.</para>
            <para>This is thread-safe.</para>
            </summary>
            <param name="method">e.g. MethodInfo.GetCurrentMethod()</param>
            <param name="inputArguments">
            <para>Primitives, objects that are not a collection of any sort, arrays and ILists are supported. Array / IList members are compared for equality.</para>
            <para>Override InspectArgumentEquality(object, object) if you want to for instance support dictionaries.</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.FunctionOutputCache.InspectArgumentEquality(System.Object,System.Object)">
            <summary>
            <para>Primitives, objects that are not a collection of any sort, arrays and ILists are supported. Array / IList members are compared for equality.</para>
            <para>Override this if you want to for instance support dictionaries.</para>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.FunctionOutputCache.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="P:RandomUtils.FunctionOutputCache.IsDisposed">
            <summary>
            
            </summary>
        </member>
        <member name="P:RandomUtils.FunctionOutputCache.Size">
            <summary>
            The current size of the cache.
            </summary>
        </member>
        <member name="T:RandomUtils.FunctionOutputCache.CacheEntry">
            <summary>
            Holds the MethodBase, de input and output arguments if any and the return value.
            </summary>
        </member>
        <member name="M:RandomUtils.FunctionOutputCache.CacheEntry.#ctor(System.Reflection.MethodBase,System.Object[])">
            <summary>
            </summary>
            <param name="method"></param>
            <param name="inputArguments"></param>
        </member>
        <member name="P:RandomUtils.FunctionOutputCache.CacheEntry.Method">
            <summary>
            </summary>
        </member>
        <member name="P:RandomUtils.FunctionOutputCache.CacheEntry.InputArguments">
            <summary>
            </summary>
        </member>
        <member name="P:RandomUtils.FunctionOutputCache.CacheEntry.OutputArguments">
            <summary>
            </summary>
        </member>
        <member name="P:RandomUtils.FunctionOutputCache.CacheEntry.ReturnValue">
            <summary>
            </summary>
        </member>
        <member name="T:RandomUtils.KeyValueStore">
            <summary>
            <para>A super-simple key value store implementation. Basically a wrapper around ConcurrentDictionary.</para>
            <para>You can use the instance if you want one general KeyValueStore.</para>
            </summary>
        </member>
        <member name="M:RandomUtils.KeyValueStore.GetInstance">
            <summary>
            You can use the instance if you want one general KeyValueStore.
            </summary>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.KeyValueStore.Add(System.Object)">
            <summary>
            Uses a uniquely generated key, based on a random that uses a new guid hash code for a seed.
            </summary>
            <param name="value"></param>
            <returns>The generated key.</returns>
        </member>
        <member name="M:RandomUtils.KeyValueStore.AddOrUpdate(System.Object,System.Object)">
            <summary>
            Adds or updated the key value pair.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:RandomUtils.KeyValueStore.Remove(System.Object)">
            <summary>
            Removes a key value pair if the key was found.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.KeyValueStore.Clear">
            <summary>
            Clears the store.
            </summary>
        </member>
        <member name="M:RandomUtils.KeyValueStore.Contains(System.Object)">
            <summary>
            Returns if the store contains a key value pair for the given key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.KeyValueStore.Get``1(System.Object)">
            <summary>
            Returns a value for a given key. If it was not found an exception will be thrown.
            </summary>
            <typeparam name="TV"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.KeyValueStore.Dispose">
            <summary>
            </summary>
        </member>
        <member name="P:RandomUtils.KeyValueStore.Size">
            <summary>
            The current size of the store.
            </summary>
        </member>
        <member name="P:RandomUtils.KeyValueStore.Keys">
            <summary>
            Returns all the keys.
            </summary>
        </member>
        <member name="P:RandomUtils.KeyValueStore.Values">
            <summary>
            Returns all the values.
            </summary>
        </member>
        <member name="P:RandomUtils.KeyValueStore.IsDisposed">
            <summary>
            </summary>
        </member>
        <member name="T:RandomUtils.SerializationHelper">
            <summary>
            Helper class for 'serializing / deserializing' strings, objects (gzip and deflate compression included) and structures.
            </summary>
        </member>
        <member name="M:RandomUtils.SerializationHelper.Encode(System.String,RandomUtils.SerializationHelper.TextEncoding)">
            <summary>
            Encodes a string to a byte[] using the given encoding.
            </summary>
            <param name="text"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.Decode(System.Byte[],RandomUtils.SerializationHelper.TextEncoding)">
            <summary>
            Decodes a byte[] to a string using the given encoding.
            </summary>
            <param name="arr"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.Serialize(System.Object)">
            <summary>
            Converts an object to a byte[] uncompressed.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.SerializeDeflate(System.Object,System.IO.Compression.CompressionLevel)">
            <summary>
            <para>Converts an object to a byte[] using deflate compression.</para>
            <para>Use gzip only for text, since it is optimized for that stuff according to wikipedia. Use deflate for everything else.</para>
            </summary>
            <param name="obj"></param>
            <param name="compressionLevel"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.SerializeGZip(System.Object,System.IO.Compression.CompressionLevel)">
            <summary>
            <para>Converts an object to a byte[] using gzip compression.</para>
            <para>Use gzip only for text, since it is optimized for that stuff according to wikipedia. Use deflate for everything else.</para>
            </summary>
            <param name="obj"></param>
            <param name="compressionLevel"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.Deserialize``1(System.Byte[])">
            <summary>
            <para>Converts a byte[] to an object.</para>
            <para>Throws an exception if the array could not be deserialized or the deserialized object could not be cast to the given type.</para>
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.DeserializeDeflate``1(System.Byte[])">
            <summary>
            <para>Converts a byte[] to an object. Decompressed using deflate.</para>
            <para>Throws an exception if the array could not be deserialized or the deserialized object could not be cast to the given type.</para>
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.DeserializeGzip``1(System.Byte[])">
            <summary>
            <para>Converts a byte[] to an object. Decompressed using gzip.</para>
            <para>Throws an exception if the array could not be deserialized or the deserialized object could not be cast to the given type.</para>
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.MarshalStructToBytes``1(``0)">
            <summary>
            <para>Handy for stuff from the clr / interop.</para>
            <para>Use this only for structs that contains only primitives!</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.MarshalBytesToStruct``1(System.Byte[])">
            <summary>
            <para>Handy for stuff from the clr / interop.</para>
            <para>Use this only for structs that contains only primitives!</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.BytesToHex(System.Byte[],System.String)">
            <summary>
            Converts a byte array to a hex using the given separator.
            </summary>
            <param name="arr"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.SerializationHelper.HexToBytes(System.String,System.String)">
            <summary>
            Converts a seperated hex to a byte array using the given seperator.
            </summary>
            <param name="s"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="T:RandomUtils.SerializationHelper.TextEncoding">
            <summary>
            Used in the Encode and Decode fx. UTF8 is advised.
            </summary>
        </member>
        <member name="F:RandomUtils.SerializationHelper.TextEncoding.ASCII">
            <summary></summary>
        </member>
        <member name="F:RandomUtils.SerializationHelper.TextEncoding.BigEndianUnicode">
            <summary></summary>
        </member>
        <member name="F:RandomUtils.SerializationHelper.TextEncoding.Default">
            <summary>
            Default system encoding, depends on your settings. Use UTF8 instead.
            </summary>
        </member>
        <member name="F:RandomUtils.SerializationHelper.TextEncoding.Unicode">
            <summary></summary>
        </member>
        <member name="F:RandomUtils.SerializationHelper.TextEncoding.UTF32">
            <summary></summary>
        </member>
        <member name="F:RandomUtils.SerializationHelper.TextEncoding.UTF7">
            <summary></summary>
        </member>
        <member name="F:RandomUtils.SerializationHelper.TextEncoding.UTF8">
            <summary></summary>
        </member>
        <member name="T:RandomUtils.StringUtil">
            <summary></summary>
        </member>
        <member name="M:RandomUtils.StringUtil.IsNumeric(System.Object)">
            <summary>
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.StringUtil.IsNumericType(System.Type)">
            <summary>
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.StringUtil.GenerateRandomName(System.Int32)">
            <summary>
                Generates a random name.
            </summary>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.StringUtil.GenerateRandomName(System.Int32,System.Int32)">
            <summary>
                Generates a random name with a random length.
            </summary>
            <param name="min"></param>
            <param name="max">exclusive</param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.StringUtil.GenerateRandomPattern(System.String)">
            <summary>
                generates a random word via the given pattern.
                0 = 1 numeric char (obligatory)
                9 = 1 numeric char (optional)
                A = 1 capital (obligatory)
                a = 1 non-capital (obligatory)
                B = 1 capital (optional)
                b = 1 non)capital (optional)
                # = 1 random char (obligatory)
                ? = 1 random char (optional)
                all other chars are fixed.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.StringUtil.FloatToLongString(System.Single,System.Boolean)">
            <summary>
                No Scientific notation ToString().
            </summary>
            <param name="f"></param>
            <param name="thousandSeparator"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.StringUtil.DoubleToLongString(System.Double,System.Boolean)">
            <summary>
                No Scientific notation ToString().
            </summary>
            <param name="d"></param>
            <param name="thousandSeparator"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.StringUtil.NumberToLongString(System.Object,System.Boolean)">
            <summary>
                No Scientific notation ToString().
            </summary>
            <param name="o"></param>
            <param name="thousandSeparator"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.StringUtil.ReverseString(System.String)">
            <summary>
            Reverse a string.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:RandomUtils.SynchronizationContextWrapper">
            <summary>
            <para>A wrapper for SynchronizationContext, so SynchronizationContext is available throughout the entire application.</para>
            <para>A SynchronizationContext is for synchronizing data to another thread, for instance to the main thread.</para>
            <para>Handy if you want to update a System.Windows.Forms.Label from another thread. It is the most reliable way to do something like that IMHO.</para>
            </summary>
        </member>
        <member name="P:RandomUtils.SynchronizationContextWrapper.SynchronizationContext">
            <summary>
            <para>Set this to System.Threading.SynchronizationContext.Current in the constructor below 'InitializeComponent();' of a WPF main form or when the handle is created for a WinForms main form.</para>
            <para>e.g. If you want to update a System.Windows.Forms.Label form another thread: SynchronizationContextWrapper.SynchronizationContext.Current.Send((state) => { lblFoo.Text = "bar"; }, null)</para>
            </summary>
        </member>
        <member name="T:RandomUtils.TimeSeriesStore">
            <summary>
            <para>This is a very simple time series store implementation.</para>
            <para>It is a partioned key value store with a timestamp (DateTime) for a key and an object[] for values.</para>
            <para>If you do not specify a partition in the different functions, the default is used.</para>
            <para>You can use the instance if you want one general time series store.</para>
            <para>If you want something more robust and distributed I suggest that you take a look at OpenTSDB, Reddis, etc.</para>
            </summary>
        </member>
        <member name="F:RandomUtils.TimeSeriesStore.DEFAULTPARTITION">
            <summary>
            The default partition. This one is used if you do not specify one in the different functions (Except ClearAll()).
            </summary>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.GetInstance">
            <summary>
            You can use the instance if you want one general time series store.
            </summary>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.AddOrUpdate(System.DateTime,System.Object[])">
            <summary>
            Adds or updates a time series on the default partition.
            </summary>
            <param name="timestamp"></param>
            <param name="values"></param>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.Remove(System.DateTime)">
            <summary>
            Removes a time series from the default partition, if found.
            </summary>
            <param name="timestamp"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.Clear">
            <summary>
            Clears the default partition.
            </summary>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.Get(System.DateTime)">
            <summary>
            Returns a time series from the default partition.
            </summary>
            <param name="timestamp"></param>
            <returns>If the time series was not found, null will be returned.</returns>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.AddOrUpdate(System.String,System.DateTime,System.Object[])">
            <summary>
            Adds or updates a time series on a given partition. If the partition does not exist it will be added.
            </summary>
            <param name="partition"></param>
            <param name="timestamp"></param>
            <param name="values"></param>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.Remove(System.String,System.DateTime)">
            <summary>
            Removes a time series from a given partition, if found.
            </summary>
            <param name="partition"></param>
            <param name="timestamp"></param>
            <returns></returns>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.Clear(System.String)">
            <summary>
            Clears a given partition.
            </summary>
            <param name="partition"></param>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.ClearAll">
            <summary>
            Clears all partitions.
            </summary>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.Get(System.String,System.DateTime)">
            <summary>
            Returns a time series from the given partition.
            </summary>
            <param name="partition"></param>
            <param name="timestamp"></param>
            <returns>If the time series was not found, null will be returned.</returns>
        </member>
        <member name="M:RandomUtils.TimeSeriesStore.Dispose">
            <summary>
            </summary>
        </member>
        <member name="P:RandomUtils.TimeSeriesStore.Partitions">
            <summary>
            Returns all the partition ids.
            </summary>
        </member>
        <member name="P:RandomUtils.TimeSeriesStore.IsDisposed">
            <summary>
            </summary>
        </member>
    </members>
</doc>
